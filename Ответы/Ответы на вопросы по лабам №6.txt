1. Чем класс отличается от структуры?

Структуры синтаксически очень похожи на классы, но существует принципиальное отличие, которое заключается в том, что класс – является ссылочным типом (reference type), а структуры – значимый класс (value type). А следовательно, классы всегда создаются в, так называемой, “куче” (heap), а структуры создаются в стеке (stack) 

2.  Что может и чего не может быть в структуре?
►1) Может иметь конструктор c параметрами. 
►2) нельзя определить конструктор, используемый по умолчанию (конструктор без параметров). Он определяется для всех структур автоматически и не подлежит изменению ►3) Объект структуры может быть создан с помощью оператора new (или нет) 
►4) размещение в стеке
►5) Нельзя инициализировать поля структуры при объявлении 
►6) нет автоматической инициализации полей компилятором
►7) структуры не поддерживают наследование 

►Назначение : повышении эффективности и производительности программ (тип значения)


3. Что такое перечисление? Приведите пример определения и использования перечисления

Перечисления - набор логически связанных констант.
1) тип перечисления - целочисленный тип (byte, int, short, long)
2) По умолчанию используется тип int.
Пример перечисления: 

enum MathOperation
{ 
	Add,  
 	Subtract,
 	Multiply, 
	 Divide  
  }

Перечисление - enum - это набор именованных констант, объединенных в одну сущность, позволяющих сделать исходный код программы более удобочитаемым. 
 
4. Перечислите и поясните стандартные интерфейсы .Net?

В библиотеке .NET определено множество стандартных интерфейсов, задающих желаемое поведение объектов. Например, интерфейс IComparable задает метод сравнения объектов по принципу больше или меньше, что позволяет выполнять их сортировку. Реализация интерфейсов IEnumerable и IEnumerator дает возможность просматривать содержимое объекта с помощью конструкции foreach, а реализация интерфейса ICloneable – клонировать объекты.
Стандартные интерфейсы поддерживаются многими стандартными классами библиотеки. Например, работа с массивами с помощью цикла foreach возможна именно потому, что тип Array реализует интерфейсы IEnumerable и IEnumerator. Можно создавать и собственные классы, поддерживающие стандартные интерфейсы, что позволит использовать объекты этих классов стандартными способами.
Сравнение объектов (интерфейс IComparable)
Интерфейс IComparable содержит всего один метод CompareTo(),возвращающий результат сравнения двух объектов – текущего и переданного ему в качеству параметра:
interface IComparable
{
int CompareTo(object obj)
}
Метод должен возвращать:
o 0, если текущий объект и параметр равны
o отрицательное число, если текущий объект меньше параметра
o положительное число, если текущий объект больше параметра
Во многих алгоритмах требуется выполнить сортировку по различным критериям. Для этого используется интерфейс IComparer.
Сортировка объектов по различным критериям (интерфейс IComparer)
Данный интерфейс определен в пространстве имен System.Collections. Он также содержит один методCompare(),возвращающий результат сравнения двух объектов, переданных ему в качестве параметров.
interface IComparer
{
int Compare(object obj1,object obj2)
}
Принцип применения этого интерфейса состоит в том, что для каждого критерия сортировки объектов описывается небольшой вспомогательный класс, реализующий этот интерфейс. Объект этого класса передается в стандартный метод сортировки массива в качестве второго аргумента.
Клонирование объектов (интерфейс ICloneable)
Клонирование-создание копии объекта. Копия объекта называется клоном. При присваивании одного экземпляра другому копируется ссылка, а не сам объект. Если необходимо скопировать в другую область памяти поля объекта, можно воспользоваться методом MemberwiseClone(), который любой объект наследует от класса object. При этом объекты, на которые указывают поля объекта, в свою очередь являющиеся ссылками, не копируются. Это называется поверхностным клонированием. Для создания полностью независимых объектов необходимо глубокое копирование, когда в памяти создается дубликат всего дерева объектов, то есть объектов, на которые ссылаются поля объекта, поля полей, и т.д. Алгоритм глубокого копирования сложен, требует рекурсивного обхода всех ссылок объекта и отслеживания циклических зависимостей.
Объект, имеющий собственные алгоритмы клонирования, должен объявляться как производный интерфейса ICloneable и переопределять его единственный метод Clone().


5. Как используется интерфейс Icomparable?
Интерфейс IComparable содержит всего один метод CompareTo(),возвращающий результат сравнения двух объектов – текущего и переданного ему в качеству параметра.

6. Как используется интерфейс Icloneable?

Пример

public Monster ShallowClone()
{
return (Monster)this.MemberwiseClone();
}
public object Clone()
{
return new Monster(this.сила, this.умение, "Это-клон!" + this.имя);
}
Используется для создания клона объекта.

7. Что такое полиморфизм? Перечислите его формы. Приведите примеры.
Полиморфизм — это способность обьекта использовать методы производного класса, который не существует на момент создания базового.

С полиморфизмом к нам прибавляются еще несколько понятий: виртуальный/абстрактный метод, переопределение метода.

Виртуальный метод – это метод, который МОЖЕТ быть переопределен в классе-наследнике. Такой метод может иметь стандартную реализацию в базовом классе.

Абстрактный метод – это метод, который ДОЛЖЕН быть реализован в классе-наследнике. При этом, абстрактный метод не может иметь своей реализации в базовом классе (тело пустое), в отличии от виртуального.

Переопределение метода – это изменение реализации метода, установленного как виртуальный (в классе наследнике метод будет работать отлично от базового класса).


8. Зачем в классе определяют виртуальные методы?
Чтобы после была возможность их переопределить для определенного класса.

9. Как сделать запрет переопределения методов? 
Поставить перед методом sealed.
Члены по умолчанию запечатаны в C# - если они не помечены как виртуальные, их все равно нельзя переопределить в производных классах.
они могут быть тени в производных классах, по общему признанию
